##创建型

#### 单例（singleton）

保证对一个特有的类，只有一个公共的实例存在。一般与懒加载一起出现，只有被需要时才会创建。

#### 简单工程模式

由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类的实例

#### 模板方法模式

父类负责封装不变部分的算法，子类负责可变部分的实现

##结构型

#### 装饰模式(Category,Extension,Delegateion)

可以在不修改源代码的基础上进行拓展。与继承的区别：继承时，子类可以修改父类的行为，装饰模式不希望如此

#### 适配器模式

将一个类的接口转化为另一个类的接口，使得原本互不兼容的类可以通过接口一起工作。例如将网络请求类的接口返回的数据进行转换为model或UI界面需要的数据的类

#### 外观模式

用一个公共接口来连接多个类与其他数据类型。公共接口让多个类互相保持独立，解耦性良好。同时使用接口时，外部无需理解其背后复杂的逻辑。另外就算接口背后的逻辑改变也不影响接口的使用





##行为型

#### 观察者模式(KVO，NotificationCenter)

定义对象间的一种一对多依赖关系，使得每当一个对象状态发送改变时，其相关依赖对象皆得到通知并被自动更新。

#### 备忘录模式(NSUserDefault)

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到保存之前的状态

#### 策略模式

将多重条件（if-else）语句，变成实现多个策略的类

#### 代理模式

protocol-delegate

#### 命令模式（redo - undo）

将一个请求封装成一个对象，从而可用不同的请求对客户进行参数化。对请求排队或记录日志，以及支持可撤销的操作

#### 组合模式

将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和复杂对象的使用具有一致性



## 设计模式6大原则

#### 1、单一职能原则

一个类只负责一项职责，尽量做到类只有一个行为原因引起变化；

a、业务对象、业务逻辑拆分

#### 2、里式替换原则

> 只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者根本就不需要知道是父类还是子类。但是反过来就不行，有子类出现的地方，父类未必能适应

里式替换为良好的继承定义了一个规范，包含4层含义：

- 子类必须完全实现父类的方法
- 子类可以有自己的个性
- 覆盖或实现父类的方法时输入参数可被放大（重载而非覆盖）
- 覆写或实现父类的方法时输出结果可以被缩小

#### 3、依赖倒置原则

本质是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合

面向接口编程；抽象就是接口或者抽象类，细节就是实现类

含义：

- 上层模块应该依赖下层模块，两者应该依赖其抽象

- 抽象不应该依赖细节，

- 细节应该依赖抽象

【接口负责定义public属性和方法，并且声明与其他对象依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑】

####4、接口隔离

建立单一接口（扩展也是一种接口，一切皆接口）

定义：

​	a、客户端不应该依赖它不需要的接口

​	b、类之间依赖关系应该建立在最小的接口上

【接口的设计粒度越小，系统越灵活，但是灵活的同时结构复杂性提高，开发难度也会变大，维护性降低】

#### 5、迪米特原则

最少知道原则，尽量降低类与类之间 耦合；

一个对象应该对其他对象有最少的了解

#### 6、开闭原则

一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。

用抽象构建架构，用实现扩展原则





## OOP

封装、继承、多态、抽象

#### 1、封装

将对象信息状态通过访问权限修饰符隐藏在对象内部，不允许外部程序直接访问，如果外部程序要访问对象内部，可以调用内部提供的get/set方法

#### 2、继承

子类继承了父类所有的成员和属性，并且可以拥有自己特性。继承解决了代码的重用问题

#### 3、多态

多态存在的三个条件：1、继承 2、重写 3、父类引用指向子类对象

实现方式：

1、接口实现，继承父类方法重写，同一个类中进行重载

重载：多个同名函数同时存在，具有不同的参数个数/类型，返回值类型可以相同可以不同，调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法，这就是多态性，存在于父类、子类和同类中

重写：1、参数类别必须完全与被重写的方法相同

​			2、返回的类型必须一致与被重写的方法的返回类型相同

​			3、访问修饰符的限制一定要大于被重写方法的访问修饰符

​			4、重写方法一定不能抛出新的检查异常或者比被重写方法声明更加宽泛的检查异常

​			5、存在于父类和子类之间，方法被定义为final不能被重写

#### 4、抽象

类中含有抽象方法，该方法无具体实现



参考：

1、[设计模式6大原则](https://segmentfault.com/a/1190000019426005?utm_source=tag-newest)