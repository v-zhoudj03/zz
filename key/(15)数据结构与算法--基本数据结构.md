####1、数组

```c
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // insert code here...
        int i = 0;
        int arr[3] = {0};
        for (; i <= 3; i++) {
            arr[i] = 0;
            printf("hello world\n");
        }
    }
    return 0;
}
```

在XCode：Build Phases->Compile Sources->main.m文件添加`-fno-stack-protector`编译属性，即可关闭编译器对堆栈的保护，运行，可以看到无限循环打印：hello world.



由于i和arr是在函数体内，内存是分配在栈上，栈上的内存是由高到低分配，而我的电脑系统是64位，分配内存时是8字节对齐。i和arr里数据都是int型（4字节），符合8字节对齐规则。所以内存分配依次是：i、arr[2]、arr[1]、arr[0]

当i=3时，arr[3]正好访问到i的内存地址，此时将i又重新赋值为0，所以出现了无限循环打印：hello world。



正如上面例子所示：数组的内存分配是一段连续的内存空间，类存储相同类型的一组数据，最大的特点是支持随机访问，但插入、删除操作会很低效，因为涉及到数据的搬移。

由于内存的连续性，我们可以根据下标用公式计算出对应的数据的地址，实现随机访问

> a[i] = base_address + i * data_type_size

通常，数组是以0开始编号。



对于不一定非得追求数组中数据的连续性的情况：

如果插入某个元素a到第k个位置，我们可以先将第k个元素移到数组的最后，再将a插入到第k个位置，这样就不需要将第k位后的所有数据都进行移动，提高了效率

如果是删除操作，可以将要删除的元素标记为要删除，每次的删除操作并不是真正的要搬移数据，只是记录数据已经被删除。当数组空间不够时，再一次性进行真正的删除操作，这样就大大减少了删除操作导致的数据搬移





####2、链表

链表不需要连续的内存空间，因而不能实现随机访问内存，但可以实现快速的插入和删除操作。

#####

见demo：DataStructureAndAlgorithm